# Ответы на вопросы к защите лабораторной работы

## 1. Платформа Java EE. Спецификации и их реализации.

**Java EE (Java Enterprise Edition)** представляет собой платформу для создания корпоративных приложений на языке Java. Прежде всего это сфера веб-приложений и веб-сервисов.

Основные спецификации:
* Java Servlets: серверные модули, которые обрабатывают запросы от пользователей и отправляют результат обработки.
* JavaServer Pages (JSP): серверные модули для обработки пользовательских запросов (по сути предствляют собой страницы с кодом HTML/JavaScript/CSS с вкраплениями кода на Java).
* Enterprise JavaBeans (EJB): Java классы, которые содержат бизнес-логику.
* Contexts and Dependency Injection (CDI): механизм для внедрения и управления зависимостями.
* JavaServer Faces (JSF): служит для создания пользовательского интерфейса на стороне сервера.
* Java API for RESTful Web Services (JAX-RS): API для применения архитектуры REST в приложениях.

Примеры реализаций:
* Wildfly
* Glassfish

## 2. Принципы IoC, CDI и Location Transpanency. Компоненты и контейнеры.

**Inversion of Control** - это принцип для написания слабо связанного кода. То есть такого кода, что каждый компонент системы должен быть как можно более изолированным от других, не используя реализации других компонентов.

**Внедрение зависимостей (Dependency Injection)** - это стиль настройки объекта, при котором поля объекта задаются внешней сущностью. Другими словами, объекты настраиваются внешними объектами. 

Пример внедрения зависимостей:
```java
public class MartinRaila {

  // В данном случае мы самостоятельно управляем зависимостью (создаем ее).
  private Dependency someDependency = new Dependency();
  
}
```
Перепишем код с использованием принципа внедрения зависимостей.
```java
public class MartinRaila {

  private Dependency someDependency;

  // Теперь мы принимаем зависимость извне, что избавляет компонент от необходимости ею управлять
  public MartinRaila(Dependency someDependency) {
    this.someDependency = someDependency;
  }
  
}  
```

Существует 3 типа внедрения зависимостей:
* Field injection: инъекция напрямую в поле.
* Constructor injection: инъекция в конструктор (как показано в примере выше).
* Setter injection: инъекция через специальные методы, сеттеры.

**CDI (Contexts and Dependency Injection)** - это спецификация Java EE, описывающая внедрение зависимостей и контексты.

**Компонент и контейнер** - это обычные классы. Первый требует для своей работы различные зависимости. Второй отвечает за создание объектов и их вставку.

**Прозрачность местоположения (Location transparency)** — это техника использования имен для идентификации сетевых ресурсов как таковых, а не их фактического местоположения.

## 3. Управление жизненным циклом компонентов. Дескрипторы развёртывания.

Контейнер берет на себя задачу управления жизненным циклом компонентов.

**Жизненный цикл компонентов**:
1. Создается экземпляра компонента при помощи вызова конструктора.
2. Выполняется его внедрение в необходимые компоненты.
3. Контейнер уничтожает экземпляр и все зависимые от него объекты.

**Дескриптор развертывания (Deployment descriptor)** представляет собой xml-файл, предназначенный для хранения основных параметров приложения.
Содержит информацию, которая необходима web-контейнеру для взаимодействия с приложением.

Пример дескриптора приложения с инициализацией сервлета:
```java
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee
         http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd"
         version="3.1">
    <servlet>
        <servlet-name>AlexeiEgoshinOneLove</servlet-name>
        <servlet-class>ru.cupofcode.AlexeiEgoshinOneLoveServlet</servlet-class>
    </servlet>
    <servlet-mapping>
        <servlet-name>AlexeiEgoshinOneLove</servlet-name>
        <url-pattern>/*</url-pattern>
    </servlet-mapping>
</web-app>
```
## 4. Java EE API. Виды компонентов. Профили платформы Java EE.

_Java EE API описаны в ответе **#1**._

**Профиль** — это набор технологий и API Java EE, предназначенных для конкретных сообществ разработчиков и типов приложений.

Реализации профилей:
* Полный профиль: предназначен для разработчиков, которым требуется полный набор API Java EE для создания корпоративных приложений.
* Веб-профиль: содержит веб-технологии, являющиеся частью полной платформы, и предназначен для разработчиков, которым не требуется полный набор API Java EE.

## 5. Компоненты EJB. Stateless & Stateful Session Beans. EJB Lite и EJB Full.

**EJB (Enterprise Java Bean)** — это спецификация для разработки серверных компонентов, реализующих бизнес-логику.

**Компоненты** — бобы, которые делятся на _session beans_ (сессионные) и _message driven beans_ (управляемые сообщениями).

Наиболее важное различие между компонентами, управляемыми сообщениями, и сессионными заключается в том, что клиенты не получают доступ к компонентам, управляемым сообщениями, через интерфейсы. 

Типы **Session beans**:
* Stateful: у каждого клиента свой экземпляр, в котором хранится состояние
* Stateless: один и тот же экземпляр обеспечивает запросы нескольких клиентов (такие бины лучше масштабируются, но не могут сохранять состояние между последовательными запросами пользователя)
* Singleton: один экземпляр для всего приложения

**Message driven beans** выполняют метод в ответ на получение сообщения из определенной очереди Java Message Service (стандарт обмена сообщениями между приложениями). Когда приходит сообщение, контейнер вызывает метод `onMessage` компонента, управляемого сообщениями, для обработки сообщения.

Аннотация `@EJB` предоставляет клиентам не сам объект, а прокси, через который можно получить доступ к методам бизнес-интерфейсов. Может осуществляться доступ как к локальным, так и удаленным (в другой JVM) объектам.

**EJB Lite** - это упрощенная спецификация EJB, которая предусматривает размещение в Web Container с урезанным функционалом. В ней отсутствуют: MDB, EJB2.x, Remote Interface, JAX-WS, JAX-RPC, Timer Service, Asynchronous Session Bean, RMI-IIOP.

## 6. Работа с электронной почтой в Java EE. JavaMail API.

**JavaMail API** - это библиотека, предназначенная для подключения к почтовым серверам с целью получения и отправки электронной почты с использованием протоколов SMTP, POP3 и IMAP.

Краткое описание поддерживаемых протоколов:
* SMTP (Simple Mail Transfer Protocol) - это простой протокол, используемый для рассылки писем.
* POP3 (Post Office Protocol Version 3) - это протокол, используемый для чтения писем. POP3 при загрузке письма на клиентский компьютер удаляет письмо с почтового сервера. Недостатком этого протокола является то, что при просмотре письма на одном клиентском компьютере это письмо уже нельзя будет посмотреть с другого устройства.
* IMAP (Internet Message Access Protocol) — это протокол доступа к электронной почте. Альтернатива протоколу POP3. IMAP подгружает на клиент только мета-информацию письма, а остальные данные предоставляет по требованию.

**MIME-типы (Multipurpose Internet Mail Extensions)** используются для обозначения типа передаваемого контента. Тип определяется двумя словами, записанными через слеш. Первое слово — это общий тип, а второе — уточнение. К примеру, `image/jpeg`.

Пример создания и отправки сообщения с помощью JavaMail API:
```java
try {
  // Создание объекта сообщения и его настройка
  // Создание объекта сессии отличается в зависимости от выбранного протокола (не представлено в примере)
  MimeMessage message = new MimeMessage(session);
  // Адрес отправителя
  message.setFrom(new InternetAddress("vipoliakov@itmo.ru"));
  // Адреса получателей
  message.addRecipient(Message.RecipientType.TO, new InternetAddress("meldren@itmo.ru"));
  // Тема сообщения
  message.setSubject("ДЗ #1");
  // Текст сообщения
  message.setText("Принято.");

  // Отправка сообщения
  Transport.send(message);
} catch (MessagingException ex) {
  ex.printStackTrace();
}
```

## 7. JMS. Реализация очередей сообщений. Способы доставки сообщений до клиента. Message-Driven Beans.

**JMS (Java Message Service)** — это стандарт для асинхронного распределенного взаимодействия программных компонентов путем рассылки сообщений.

JMS поддерживает две модели коммуникации: _point-to-point_ и _publish-subcribe (pubsub)_.

В **point-to-point** сообщения от разных отправителей адресуются в определенной очереди, к которой подключаются клиенты. При этом для каждого сообщения гарантируется, что оно будет доставлено одному и только одному клиенту.

В **pubsub** сообщения адресуются определенному topic'у, на которого подписываются клиенты. Каждое сообщение может быть получено несколькими клиентами или не получено вообще, если подписчиков на момент доставки не было.

Примеры реализаций JMS провайдеров:
* RabbitMQ
* Open Message Queue
* Apache ActiveMQ
* JBoss Messaging

_Message driven beans описаны в ответе **#5**._

## 8. Понятие транзакции. Управление транзакциями в Java EE. JTA.

**Транзакция** — это группа последовательных операций, которая образует логическую единицу работы с данными. Транзация либо выполняется успешно и целиком, соблюдая целостность данных, либо не производит никакого эффекта на данные.

**JTA (Java Transaction API)** позволяет выполнять распределенные транзакции, т.е. транзакции, оперирующие данными на разных сетевых ресурсах (серверы баз данных, JMS).

JTA предоставляет высокоуровневый интерфейс для управления транзакциями (через методы `begin`, `commit`, `rollback`), избавляя разработчика от необходимости работы с каждым ресурсом по-своему.

Транзация координируется transaction manager'ом. Взаимодействие с ресурсами осуществляется через resource manager'ы.

Виды объявления транзакций:
* Декларативно: аннотацией `@Transactional` на методе или всем классе (rollback происходит при выбрасывании необработанной `RuntimeException`)
* Программно: вызвав `begin`, `rollback`, `commit` у `UserTransaction` (интерфейс для ручного управления транзакциями)

## 9. Веб-сервисы. Технологии JAX-RS и JAX-WS.

**Веб-сервис** - это программы, которые могут взаимодействовать друг с другом и со сторонними приложениями посредством сообщений, основанных на определённых протоколах.

Основные стандарты веб-сервисов:
* SOAP (Simple Object Access Protocol): перед вызовом удаленной процедуры необходимо описать вызов в XML файле формата SOAP. По сути является еще одной из многочисленных XML разметок, которая используется в веб-сервисах. Все, что мы хотим куда-то отправить через HTTP, сначала превращается в XML описание SOAP, потом засовывается в HTTP пакет и посылается на другой компьютер в сети по TCP/IP.
* WSDL (Web Services Description Language): стандарт, который требует, чтобы наличие описания веб-сервиса, в котором сказано, что «да, вы не ошиблись – это действительно веб-сервис и можно у него вызвать такие-то такие-то методы». Такое описание представляется еще одним файлом XML, который имеет формат WSDL. То есть WSDL – это просто XML файл описания веб-сервиса.

_JAX-WS_ и _JAX-RS_ - это мощные API для разработки веб-сервисов, предоставляемые Java.

**Отличия**
| **JAX-WS** | **JAX-RS** |
|:---:|:---:|
| В качестве основного метода связи используется SOAP | Используется архитектурная структура Restful для связи между клиентом и сервером |
| Взаимодействует посредством сообщений в формате XML | Может взаимодействовать через XML, HTML, JSON и HTTP |
| В основном используется для создания веб-сервисов на уровне предприятия, где есть строгие форматы данных, которые необходимо соблюдать | В основном используется в приложениях для смартфонов и для веб-интеграции |

## 10. Платформа Spring. Сходства и отличия с Java EE.

**Spring Framework** представляет собой контейнер внедрения зависимостей с несколькими удобными слоями (например: доступ к базе данных, прокси, аспектно-ориентированное программирование, RPC, веб-инфраструктура MVC). Все это позволяет быстрее и удобнее создавать Java-приложения.

Проведём небольшое сравнение Java EE и Spring.

**Java EE**
| Преимущества | Недостатки |
|:---:|:---:|
| Приложения, написанные на Java EE, считаются более надежными, безопасными и масштабируемыми | Очень сложная среда разработки приложений, которую сложно понять новичкам (и старичкам порой тоже) |
| Утвержденный промышленностью стандарт API | Окончательная стоимость проекта, включая разработку, развертывание и разработку приложений, может оказаться непомерно высокой |
| Преимущественно основан на аннотациях и CDI, как впрочем и Spring |
| Реализация на основе EJB контейнеров и POJO |
| Сложные приложения с большим количеством транзакций очень хорошо обрабатываются |
| Успешен в использовании для масштабируемого монолитного приложения |
| Имеется свой ООП язык, содержащий определенный стиль и синтаксис |

**Spring**
| Преимущества | Недостатки |
|:---:|:---:|
| Позволяет эффективно организовывать взаимодействия объектов | Относительно сложно развивать, поскольку в нем отсутствует четкая направленность |
| Более прост, нежели Java EE | Для начинающего разработчика изучение среды может быть сложной задачей |
| Имеет более слабую связанность приложений (реализация IoC) | Медленнее, чем Java EE |
| Работает на основе конфигурации XML, Groovy (ООП язык, дополняющий Java возможностями Python, Ruby и Smalltalk) или аннотаций |
| Использует POJO, благодаря чему разработчикам не нужен корпоративный контейнер, такой как сервер приложений |
| Обеспечивает разработчикам Java высокий уровень модульности |
| Предоставляет более удобную реализацию библиотек Java EE |
| Лицензия с открытым исходным кодом |
| Spring Boot сильно упрощает первичную настройку приложения |
| Код приложения Spring, как правило, прост для тестирования |

## 11. Модули Spring. Архитектура Spring Runtime. Spring Security и Spring Data.

Spring Framework делится на большое количество **модулей**, подключение которых добавляет определенный функционал.

**Описание основных модулей**:

**Spring Boot** — это комплексный фреймворк для создания и запуска приложений с минимальными усилиями и настройками. Этот модуль делится на два стека: основанный на API сервлетов Spring MVC (построен на API сервлетов с моделью «один запрос на поток») и реактивный Spring WebFlux (максимально использует преимущества современных многоядерных процессоров).

_Использование_: С помощью Spring Boot можно создавать микросервисы, реактивные системы, веб-приложения.

**Spring Data** обеспечивает приложениям доступ к данным через базы данных. Использует JPA Entity для взаимодействия с данными. Поддерживает реляционные и нереляционные базы данных, map-reduce фреймворки и облачные сервисы. Также позволяет использовать подмодули, разработанные сообществом Spring для более специфичных баз данных вроде ArangoDB, Google Datastore, Microsoft Azure Cosmos DB и других.

_Использование_: Везде, где нужен доступ к данным.

**Spring Cloud** позволяет легко и быстро создавать шаблоны в распределённых системах. Из примеров таких шаблонов: управление конфигурацией, обнаружение сервисов, интеллектуальная маршрутизация, микропрокси, одноразовые токены и многое другое.

_Использование_: Содержит много полезных инструментов для микросервисов и распределённых систем.

**Spring Security** — это среда аутентификации, авторизации и контроля доступа. Это стандартный фреймворк, который используется для защиты приложений. Предоставляет базовые функции безопасности, которые можно легко расширить для собственных нужд.

_Использование_: Обеспечение проверки безопасности и защиты приложения от атак.

**Spring Integration** позволяет облегчить обмен сообщениями в приложениях на основе Spring, поддерживает интеграцию с внешними системами и даёт инструменты для обработки данных из разных источников.

_Использование_: Позволяет связать POJO с помощью парадигмы обмена сообщениями без внедрения зависимостей.

**Spring Batch** — это платформа для разработки пакетных приложений. Подойдёт как для простых, так и для более сложных проектов — платформа легко масштабируется и может обрабатывать большие объёмы информации.

_Использование_: Создание приложений с многократно используемыми функциями (Например: ведение логов, управление транзакциями), чтобы обрабатывать большие объёмы записей.

## 12. Реализация IoC и CDI в Spring. Сходства и отличия с Java EE.

`ApplicationContext` представляет собой Spring IoC контейнер и необходим для инициализации, настройки и сборки бинов для построения приложения. В метаданных конфигурации разработчик описывает как инициализировать, настроить IoC контейнер и собрать объекты в приложении.

Основными признаками и частями Java-конфигурации IoC контейнера являются классы с аннотацией `@Configuration` и методы с аннотацией `@Bean`. Аннотация `@Bean` используется для указания того, что метод создает, настраивает и инициализирует новый объект, управляемый Spring IoC контейнером.

Рассмотрим создание управляемого бина на Spring и Java EE:
1. Определение бина

Spring:
```java
// Лучше использовать производные от аннотации @Component (@Controller, @Service, @Repository) в зависимости от предназначения бина, чтобы явно обозначить логику бина и расширить его функционал
@Component
public class MyClass{
}
```
Java EE:
```java
@Named
public class MyClass {
}
```
2. Внедрение бина

Spring:
```java
@Controller
public class MyClass {

  @Autowired
  AnotherClass another;
  
}

@Component
public class AnotherClass{
}
```
Java EE:
```java
@Named
public class MyClass {

  @Inject
  AnotherClass another;
  
}

public class AnotherClass {
}
```
3. Ивенты жизненного цикла бина

Spring:
```java
@Component
public class AnotherClass {

    @PostConstruct
    public void init() {
      // Данный метод будет вызван после внедрения бина
    }
    
    @PreDestroy
    public void destroy() {
      // Данный метод будет вызван перед уничтожением бина
    }
    
}
```
Java EE:
```java
public class AnotherClass {

    @PostConstruct
    public void init() {
      // Данный метод будет вызван после внедрения бина
    }
    
    @PreDestroy
    public void destroy() {
      // Данный метод будет вызван перед уничтожением бина
    }
    
}
```
4. Определение области видиости бина

Spring:
```java
@Component
// Аттрибут proxyMode необходим для внедрения бина с меньшим сроком жизни (request) в бин с большим сроком жизни (singleton)
// Spring оборачивает экземпляр бина в динамический прокси
@Scope(proxyMode = ScopedProxyMode.TARGET_CLASS, value = "request")
public class AnotherClass {
}
```
Java EE:
```java
@Named
@RequestScoped // Существуют также @SessionScoped, @ApplicationScoped и другие
public class AnotherClass {
}
```

Таким образом, Spring и Java EE предоставляют очень функциональные контейнеры. Как можно уведить из примеров выше, их функционал очень схож.

## 13. Реализация REST API в Java EE и Spring.

**Реализация REST API в Java EE**:

JAX-RS — это набор спецификаций для построения REST-сервисов. Наиболее известными эталонными реализациями являются RESTEasy и Jersey.
(_Более подробно JAX-RS описан в ответе **#9**._)

Пример реализации простого контроллера:
```java
// Путь, запрос на который выполнится обработчиками ниже
@Path("/hello")
public class HelloController {

    // Определение HTTP метода
    @GET
    // Установка типа возвращаемого значения ("text/plain")
    @Produces(MediaType.TEXT_PLAIN)
    public Response hello() {
        // Возвращение пользователю ответа в виде простого текста "Hello, world!"
        return Response.ok("Hello, world!").build();
    }

}
```

**Реализация REST API в Spring**:

Spring MVC — это модуль Spring Framework для создания веб-приложений, добавляющий возможности REST.

Пример реализации аналогичного контроллера:
```java
@RestController
@RequestMapping("/hello")
public class HelloController {

    @GetMapping(value = "/name", produces = MediaType.TEXT_PLAIN_VALUE)
    public ResponseEntity<?> hello() {
        return new ResponseEntity<>("Hello, world!", HttpStatus.OK);
    }

}
```

**Отличия**:

JAX-RS предоставляет набор аннотаций для применения их к простым объектам. Эти аннотации помогают нам абстрагироваться от низкоуровневых деталей взаимодействия клиент-сервер. JAX-RS — это только **спецификация**, и для ее использования требуется совместимая реализация.

Spring MVC в свою очередь является полноценным фреймворком с возможностями REST. Как и JAX-RS, он также предоставляет нам полезные аннотации для абстрагирования от низкоуровневых деталей. Его главное преимущество заключается в том, что он является частью Spring Framework. Таким образом, это позволяет нам использовать внедрение зависимостей, как и любой другой модуль Spring.

## 14. React JS. Архитектура и основные принципы разработки приложений.

**React** — это JavaScript-библиотека для создания пользовательских интерфейсов.

React основан на компонентном подходе: вы можете разрабатывать приложение c помощью React просто указывая в каком виде вы хотели бы видеть тот или иной элемент. React будет автоматически обновлять элемент, когда лежащие в его основе данные изменятся.
Например: автоматическое высчитывание отметок на графике в лабораторной работе относительно выбранного радиуса (Если R = 1, то R/2 и R будут заменены на 0.5 и 1)

Главные принципы: 
* Гибкость
* Эффективность 
* Декларативный код (описание конечного результата вместо конкретных шагов для достижения конечного результата)

Так как React гибкий, то можно использовать один и тот же код в нескольких проектах, создавать на его основе новые приложения и даже использовать в уже существующей базе код без переработок.

Сам по себе React отвечает только за представление (view) в MVC. Модель (model) реализуется при помощи шаблона проектирования Flux. Это архитектура, ответственная за создание слоя данных в JavaScript приложениях и разработку серверной стороны в веб-приложениях. Flux дополняет составные компоненты представления в React.

## 15. Компоненты React. State & props. "Умные" и "глупые" компоненты.

**Компоненты** позволяют разбить интерфейс на независимые части, про которые легко думать в отдельности. Их можно складывать вместе и использовать несколько раз. Во многом компоненты ведут себя как обычные функции JavaScript. Они принимают произвольные входные данные (так называемые «пропсы») и возвращают React-элементы, описывающие, что мы хотим увидеть на экране.

Пример компонента:
```js
function Welcome(props) {
  return <h1>Привет, {props.name}</h1>;
}

const root = ReactDOM.createRoot(document.getElementById('root'));
const element = <Welcome name="Саша"/>;
root.render(element);
```
Этот компонент выведет «Привет, Саша» на страницу.

**Пропсы (сокращённо от «properties»)** и **state** — это обычные JavaScript-объекты. Но несмотря на то, что оба содержат информацию, которая влияет на то, что мы увидим после рендера, есть существенное различие: props передаётся в компонент (как параметры функции), в то время как state находится внутри компонента (по аналогии с переменными, которые объявлены внутри функции).

**"Глупые" компоненты** не выполняют никаких сверхсложных задач. Все их действия просты и однообразны, они всего лишь выводят данные, принимаемые ими от свойств (пропсов).

**"Умные" компоненты** выполняют более масштабные задачи. Они управляют простыми компонентами, делают запросы на сервер и многое другое.

## 16. Разметка страниц в React-приложениях. JSX.

**JSX (JavaScript XML)** — это расширение синтаксиса JavaScript, которое позволяет использовать HTML-подобный синтаксис для описания структуры интерфейса.

Пример использования JSX:
```js
const name = 'Своевременно'
const element = <h1>Когда результаты? {name}.</h1>
```

После компиляции каждое JSX-выражение становится обычным вызовом JavaScript-функции, результат которого — объект JavaScript.
Из этого следует, что JSX можно использовать внутри инструкций `if` и циклов `for`, присваивать переменным, передавать функции в качестве аргумента и возвращать из функции.
```js
function getGreeting(user) {
  if (user) {
    return <h1>Здравствуй, {formatName(user)}!</h1>
  }
  return <h1>Здравствуй, незнакомец.</h1>
}
```

Данные, введённые пользователем, можно безопасно использовать в JSX, так как React DOM экранирует все значения, включённые в JSX перед тем как отрендерить их. Это гарантирует, что вы никогда не внедрите чего-либо, что не было явно написано в вашем приложении.
```js
const title = response.input
// Безопасный код
const element = <h1>{title}</h1>
```

JSX является синтаксическим сахаром для функции React.createElement(component, props, ...children).

Такой JSX-код:
```js
<MyButton color="red" size={5}>
  Чо палишь?
</MyButton>
```
Скомпилируется в:
```js
React.createElement(
  MyButton,
  {
    color: 'red',
    size: 5
  },
  'Чо палишь?'
)
```

## 17. Навигация в React-приложениях. ReactRouter.

**Маршрутизация** - это процесс, в котором пользователь направляется на разные страницы в зависимости от его действий (Например: нажатие на кнопку, значок, изображение и т.д.).

React Router используется для создания различных маршрутов в одностраничном приложении. Это стандартный пакет маршрутизации, используемый для реагирования на изменение представлений и перемещение между страницами.

Компоненты React Router:
* \<BrowserRouter\>: реализация маршрутизатора, которая может включать маршрутизацию в React. Он использует API HTML5, чтобы пользовательский интерфейс синхронизировался с URL-адресом. Это родительский компонент, который используется для хранения всех других компонентов и использует обычные URL-адреса
* \<Route\>: компонент, который отображает некоторый пользовательский интерфейс, когда его путь совпадает с текущим URL-адресом
* \<Link\>: используется для создания ссылок на разные маршруты и реализует навигацию по приложению. Принимает свойство, которое указывает, куда мы хотим, чтобы ссылка переместила нашего пользователя
* \<Switch\>: используется для визуализации только первого маршрута, который соответствует местоположению, а не для визуализации всех совпадающих маршрутов
  
Пример использования ReactRouter:
```js
export default function ReactRouterExample() {
  return (
    <Router>
      <div>
        // Инициализируем маршруты
        <Link to="/">Main</Link>
        <Link to="/auth">Auth</Link>
        
        // <Switch> находит первое совпадение по текущему URL и загружает это представление
        // (Похож на switch-case в Java)
        <Switch>
          // Указываем компоненты для обработки каждого URL
          <Route exact path="/">
            <Main />
          </Route>
          <Route path="/auth">
            <Auth />
          </Route>
        </Switch>
      </div>
    </Router>
  )
}

// Сами компоненты
function Main() {
  return (
    <div>
      <h2>Это главная страничка :3</h2>
    </div>
  )
}

function Auth() {
  return (
    <div>
      <h2>Пройди аутентификацию, сладкий <3</h2>
    </div>
  )
}
```

## 18. Управление состоянием интерфейса. Redux.

**Redux** — популярный менеджер состояний в веб-приложениях. Обычно его используют в связке с React, но также поддерживаются Angular, Vue и даже ванильный JavaScript.

**Использование**: если в приложении несколько компонентов, которым необходимо совместно использовать одно и то же состояние, при этом сами компоненты расположены в разных частях приложения, то без Redux управлять состоянием будет сложно.

Основная идея Redux — создать централизованное место для хранения глобального состояния приложения. Для достижения этой цели используются три основные концепции:
* Единственный источник состояния
* Состояние доступно только для чтения
* Изменения вносятся только через редукторы (функции, которые берут предыдущее состояние и переданное действие, а затем на их основе вычисляют новое состояние)

## 19. Angular: архитектура и основные принципы разработки приложений.

**Angular** — это фреймворк JavaScript, помогающий разработчикам создавать веб-приложения. Написан на языке TypeScript командой из компании Google, а также сообществом разработчиков из различных компаний.

**Использование**: технически может использоваться где угодно, но лучше всего он работает в нестандартных приложениях с данными, т.е. с form-based приложениями. Если вы ознакомитесь с реальными приложениями на Angular, то большинство из них будет собирать данные из форм и осуществлять их обработку.

## 20. Angular: модули, компоненты, сервисы и DI.

**Angular модуль** - это класс с декоратором `@NgModule()`, который служит объединяющей структурой для компонентов, директив, фильтров и сервисов. Все перечисленные сущности определяются и конфигурируются с помощью `@NgModule()`.

**Angular Компонент** - это обособленная часть функционала со своей логикой, HTML-шаблоном и CSS-стилями. Класс становится Angular компонентом, если его объявлению предшествует декоратор `@Component()` с объектом конфигурации.

Angular приложение имеет модульную архитектуру и состоит, по крайней мере, из одного главного, или корневого, модуля. Все остальные относятся к второстепенным.

**Сервисы** в Angular представляют довольно широкий спектр классов, которые выполняют некоторые специфические задачи (Например: логгирование, работа с данными). В отличие от компонентов сервисы не работают с представлениями, то есть с разметкой html.

Стандартные задачи сервисов:
* Предоставление данных приложению
* Представление канала взаимодействия между отдельными компонентами приложения
* Инкапсуляция бизнес-логики

Самый простой пример **DI** в Angular - это использованием компонентом сервиса, чаще всего для получения данных.

Для того чтобы созданный сервис мог быть использован компонентом или другим сервисом, его объявление должно быть помечено декоратором `@Injectable()`.

## 21. Angular: шаблоны страниц, жизненный цикл компонентов, подключение CSS.

В Angular представление (view) это проекция модели (model) через HTML-шаблон (template). Это означает, что всякий раз, когда модель изменяется, Angular обновляет соответствующие связывания, которые обновляют представление.

После создания компонента Angular вызывает у этого компонента ряд методов, которые представляют различные этапы **жизненного цикла**:
* ngOnChanges: вызывается при начальной установке свойств и их переустановке или изменении значений
* ngOnInit: вызывается один раз после установки свойств компонента, которые участвуют в привязке
* ngDoCheck: вызывается при каждой проверке изменений свойств компонента
* ngAfterContentInit: вызывается один раз после вставки содержимого в представление компонента кода HTML
* ngAfterContentChecked: вызывается при проверке изменений содержимого, которое добавляется в представление компонента
* ngAfterViewInit: вызывается после инициализации представления компонента, а также представлений дочерних компонентов
* ngAfterViewChecked: вызывается после проверки на изменения в представлении компонента, а также проверки представлений дочерних компонентов
* ngOnDestroy: вызывается перед удалением компонента

**Стилизация компонентов** может производиться как с помощью установки стилей в самом компоненте, так и с помощью подключения внешних css-файлов.
Для установки стилей в директиве `@Component` определено свойство `styles`.

Пример стилизации внутри компонента:
```ts
@Component({
    selector: 'my-app',
    template: `<h1>Чувствуешь этот запах?... Так пахнет допса :3</h1>`,
    styles: [` 
            h1 {
              color: navy;
              font-size: 15px;
            }
    `]
})
export class AppComponent {}
```

## 22. Angular: клиент-серверное взаимодействие, создание, отправка и валидация данных форм.

**Взаимодействие с сервером** осуществляется через протокол HTTP с помощью класса HttpClient. Он определяет ряд методов для отправки различного рода запросов: GET, POST, PUT, DELETE. Данный класс построен поверх стандартного объекта в JavaScript — XMLHttpRequest.

Для того чтобы задать валидацию, используются стандартные атрибуты валидации форм HTML5 (required, minlength, max, pattern и т.д.).
Вывод сообщений, информирующих о неправильно заполненном поле, осуществляется на основе данных состояния поля. Доступ к этим данным может быть получен с помощью шаблонной переменной.

Пример создания простой формы и её валидации:
```ts
<form>
  <div>
    <label>Ваш возраст:</label>
    <input
      type="number"
      [(ngModel)]="person.age"
      #age="ngModel"
      max="120"
      required
    />
    <input type="submit" value="Отправить" />
  </div>
</form>
```
Теперь переменная `#age` содержит объект с информацией о поле.

# Ну.. как-то так получилось. Надеюсь, ключевые моменты объяснил доступно и понятно. Love you <3
